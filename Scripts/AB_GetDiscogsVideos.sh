#!/bin/bash

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([path_output],[p],[Optional. The folder to which the extract files are written. If not supplied the files are written to the folder where this script resides.],[])
# ARG_OPTIONAL_SINGLE([output_file],[o],[Optional. The root name of the output file. If not supplied then the default value 'output' is used. If there is only one output file it has the root name, e.g. output.csv. If there are multiple output files then a number is appended to the root name, e.g. output_01.csv, output_02.csv, etc.],[output])
# ARG_OPTIONAL_SINGLE([rows_output],[r],[Optional. The number of rows per output file. Must be an integer from 150,000 to [int]::MaxValue (the largest integer value in PowerShell, 2,147,483,647). When the process has written this number of rows to the output file it closes it and opens a new one. The default is MaxValue, which ensures there will only be one ouptut file. The number of output files is capped at 99. The lower bound of 150,000 is intended to ensure that this number will not be exceeded.],[])
# ARG_OPTIONAL_SINGLE([size_block],[s],[Optional. Because the input file is too large to hold in memory the executable reads data in blocks. A block must be large enough to ensure that it always contains a complete record, so must be twice the length of the longest record, which is currently around 825,000 bytes. The read block size in bytes is 2^size_block, so for the default value of 26 this is 64 MiB. The minimum allowed is 21, corresponding to 2 MiB. The maximum is 32 (4 GiB).],[])
# ARG_OPTIONAL_SINGLE([update_percentage],[u],[Optional. The percentage of the total expected processing time per progress update. Must be an integer from 1 to 100. The default is 5 (which implies (100 / 5) = 20 progress updates).],[])
# ARG_OPTIONAL_BOOLEAN([no_check],[n],[Optional. Omit to validate that the script and executable are in the same folder. Include to skip this check.],[])
# ARG_POSITIONAL_SINGLE([input_file],[Mandatory. The Discogs xml file from which the videos extract is sought. Must be a complete path including the filename and extension.],[])
# ARG_TYPE_GROUP([pint],[r],[rows_output])
# ARG_TYPE_GROUP([pint],[u],[update_percentage])
# ARG_TYPE_GROUP_SET([s],[s],[size_block],[21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])
# ARG_DEFAULTS_POS([])
# ARG_HELP([Argbash-based argument parsing script for GetDiscogsVideos executable.])
# ARG_VERBOSE([v])
# ARG_VERSION_AUTO([_ARGBASH_VERSION],[],[],[version],[])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


# *** START BLOCK. Lines added manually before the argbash template-generated code.
# Make script terminate on error. Omit option -x which causes every executed command to be displayed.
set -euo pipefail  

# Set maximum and minimum values for rows_output.
readonly ROWS_OUTPUT_MAX=2147483647
readonly ROWS_OUTPUT_MIN=150000
readonly UPDATE_PERCENTAGE_MAX=100
readonly UPDATE_PERCENTAGE_MIN=1
# *** END BLOCK


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

# validators

pint()
{
	printf "%s" "$1" | grep -q '^\s*[+]\?0*[1-9][0-9]*\s*$' || die "The value of argument '$2' is '$1', which is not a positive integer."
	printf "%d" "$1"
}


s()
{
	local _allowed=("21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31" "32") _seeking="$1"
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && echo "$element" && return 0
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31' and '32'" 4
}


begins_with_short_option()
{
	local first_option all_short_options='porsunhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_input_file=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_path_output=
_arg_output_file="output"
_arg_rows_output="$ROWS_OUTPUT_MAX"
_arg_size_block="26"
_arg_update_percentage="5"
_arg_no_check="off"
_arg_verbose=0


print_help()
{
	printf '%s\n' "Argbash-based argument parsing script for GetDiscogsVideos executable."
	printf 'Usage: %s [-p|--path_output <arg>] [-o|--output_file <arg>] [-r|--rows_output <r>] [-s|--size_block <s>] [-u|--update_percentage <u>] [-n|--(no-)no_check] [-h|--help] [-v|--verbose] [--version] <input_file>\n' "$0"
	printf '\t%s\n' "<input_file>: Mandatory. The Discogs xml file from which the videos extract is sought. Must be a complete path including the filename and extension."
	printf '\t%s\n' "-p, --path_output: Optional. The folder to which the extract files are written. If not supplied the files are written to the folder where this script resides."
	printf '\t%s\n' "-o, --output_file: Optional. The root name of the output file. If not supplied then the default value 'output' is used. If there is only one output file it has the root name, e.g. output.csv. If there are multiple output files then a number is appended to the root name, e.g. output_01.csv, output_02.csv, etc."
	printf '\t%s\n' "-r, --rows_output: Optional. The number of rows per output file. Must be an integer from 150,000 to 2,147,483,647 (which is [int]::MaxValue, the largest integer value in PowerShell). When the process has written this number of rows to the output file it closes it and opens a new one. The default is MaxValue, which ensures there will only be one ouptut file. The number of output files is capped at 99. The lower bound of 150,000 is intended to ensure that this number will not be exceeded." 
	printf '\t%s\n' "-s, --size_block: Optional. Because the input file is too large to hold in memory the executable reads data in blocks. A block must be large enough to ensure that it always contains a complete record, so must be twice the length of the longest record, which is currently around 825,000 bytes. The read block size in bytes is 2^size_block, so for the default value of 26 this is 64 MiB. The minimum allowed is 21, corresponding to 2 MiB. The maximum is 32 (4 GiB)." 
	printf '\t%s\n' "-u, --update_percentage: Optional. The percentage of the total expected processing time per progress update. Must be an integer from 1 to 100. The default is 5 (which implies (100 / 5) = 20 progress updates)."
	printf '\t%s\n' "-n, --no_check, --no-no_check: Optional. Omit to validate that the script and executable are in the same folder. Include to skip this check."
	printf '\t%s\n' "-h, --help: Prints help."
	printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)."
	printf '\t%s\n' "--version: Prints version."
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-p|--path_output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_path_output="$2"
				shift
				;;
			--path_output=*)
				_arg_path_output="${_key##--path_output=}"
				;;
			-p*)
				_arg_path_output="${_key##-p}"
				;;
			-o|--output_file)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output_file="$2"
				shift
				;;
			--output_file=*)
				_arg_output_file="${_key##--output_file=}"
				;;
			-o*)
				_arg_output_file="${_key##-o}"
				;;
			-r|--rows_output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_rows_output="$(pint "$2" "rows_output")" || exit 1
				shift
				;;
			--rows_output=*)
				_arg_rows_output="$(pint "${_key##--rows_output=}" "rows_output")" || exit 1
				;;
			-r*)
				_arg_rows_output="$(pint "${_key##-r}" "rows_output")" || exit 1
				;;
			-s|--size_block)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_size_block="$(s "$2" "size_block")" || exit 1
				shift
				;;
			--size_block=*)
				_arg_size_block="$(s "${_key##--size_block=}" "size_block")" || exit 1
				;;
			-s*)
				_arg_size_block="$(s "${_key##-s}" "size_block")" || exit 1
				;;
			-u|--update_percentage)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_update_percentage="$(pint "$2" "update_percentage")" || exit 1
				shift
				;;
			--update_percentage=*)
				_arg_update_percentage="$(pint "${_key##--update_percentage=}" "update_percentage")" || exit 1
				;;
			-u*)
				_arg_update_percentage="$(pint "${_key##-u}" "update_percentage")" || exit 1
				;;
			-n|--no-no_check|--no_check)
				_arg_no_check="on"
				test "${1:0:5}" = "--no-" && _arg_no_check="off"
				;;
			-n*)
				_arg_no_check="on"
				_next="${_key##-n}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-n" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--verbose)
				_arg_verbose=$((_arg_verbose + 1))
				;;
			-v*)
				_arg_verbose=$((_arg_verbose + 1))
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--version)
				printf '%s %s\n\n%s\n' "AB_GetDiscogsVideos.sh" "2.10.0" 'Argbash-based argument parsing script for GetDiscogsVideos executable.'
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'input_file'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_input_file "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash
# Validation of values


### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


### ARGUMENT PARSING ###


# Set maximum and minimum values for rows_output.
# readonly ROWS_OUTPUT_MAX=2147483647
# readonly ROWS_OUTPUT_MIN=150000

# Set the executable name to be the name of this script after removing the prefix AB_ and extension .sh
shopt -s extglob
executable_name="$(basename "$0")"
executable_name="${executable_name##*(AB_)}"
executable_name="${executable_name%%*(.sh)}"
executable_path="${0%/*}"
shopt -u extglob


# If the input file is not valid then terminate.
if [[ ! -f "$_arg_input_file" ]]
  then echo -e "\nInput file or path not valid: $_arg_input_file. Process terminated.\n"
  exit
fi

# If rows_output is outside the allowed range then terminate.
if [ $_arg_rows_output -lt $ROWS_OUTPUT_MIN ] || [ $_arg_rows_output -gt $ROWS_OUTPUT_MAX ] 
	then echo -e "Argument rows_output: $_arg_rows_output. Outside the admissible range [$ROWS_OUTPUT_MIN, $ROWS_OUTPUT_MAX]. Process terminated.\n"
	exit
fi

# If update_percentage is outside the allowed range then terminate.
if [ $_arg_update_percentage -lt $UPDATE_PERCENTAGE_MIN ] || [ $_arg_update_percentage -gt $UPDATE_PERCENTAGE_MAX ] 
	then echo -e "Argument update_percentage: $_arg_update_percentage. Outside the admissible range [$UPDATE_PERCENTAGE_MIN, $UPDATE_PERCENTAGE_MAX]. Process terminated.\n"
	exit
fi

# If the path_output is not supplied make it the local path (i.e. the path of this script as given by $BASH_SOURCE[0]).
# If the output folder is supplied but is not valid then terminate.
local_folder=$(realpath "$(dirname "${BASH_SOURCE[0]}")")
if [[ -z $_arg_path_output ]]
  then
    if [[ $_arg_verbose -gt 0 ]] 
      then echo "Output file will be written to folder $local_folder"
	fi
  _arg_path_output=$local_folder
elif [[ ! -d "$_arg_path_output" ]]
  then echo -e "\nOutput folder not valid: $_arg_path_output. Process terminated.\n"
  exit
fi

# Delete leading and trailing whitespaces and trailing / using extglob.
# https://www.cyberciti.biz/faq/bash-remove-whitespace-from-string/
shopt -s extglob
_arg_path_output="${_arg_path_output##*( )}"
_arg_path_output="${_arg_path_output%%*( )}"
_arg_path_output="${_arg_path_output%%*(/)}"
shopt -u extglob

# Ensure the output folder name has a trailing forward slash.
_arg_path_output+="/"

#Set multiple_files.
multiple_files="true"
if [ $_arg_rows_output -eq $ROWS_OUTPUT_MAX ]
	then multiple_files="false"
fi 

# If output files already exist then terminate.
# In the case of multiple output files check for the existence of all files of form output_nn.csv for nn = 01 to 99.
if [ $multiple_files == "false" ]
then 
	output_file_full="$_arg_path_output$_arg_output_file.csv"
	if [[ -f "$output_file_full" ]]
		then echo -e "\n$_arg_output_file.csv already exists in the output folder. Process terminated.\n"
		exit
	fi
else
	for i in {1..99}
	do
		ext="_"
		if [ $i -lt 10 ]
			then ext+="0"
		fi
		output_file_full="$_arg_path_output$_arg_output_file$ext$i.csv" 
		if [[ -f "$output_file_full" ]]
	  		then echo -e "\n$_arg_output_file$ext$i.csv already exists in the output folder. Process terminated.\n"
	  		exit
		fi
	done
fi

# Check that the executable file is found in the same folder as the script. 
# $_arg_no_check = "off" (the default) means the check is carried out.
if [[ $_arg_no_check == "off" ]]
  then if [[ ! -f "$local_folder/$executable_name" ]]
    then echo -e "\nExecutable $executable_name not found in folder $local_folder. Process terminated.\n"
	exit
  fi
fi

if [[ $_arg_verbose -gt 0 ]]
  then
	printf 'Value of --%s: %s\n' 'path_output' "$_arg_path_output"
	printf 'Value of --%s: %s\n' 'output_file' "$_arg_output_file"
	printf 'Value of --%s: %s\n' 'rows_output' "$_arg_rows_output"
	printf 'Value of --%s: %s\n' 'size_block' "$_arg_size_block"
	printf 'Value of --%s: %s\n' 'update_percentage' "$_arg_update_percentage"
    printf "'%s' is %s\\n" 'no_check' "$_arg_no_check"
    printf "Value of '%s': %s\\n" 'input_file' "$_arg_input_file"
    printf "Value of '%s': %s\\n" 'verbose' "$_arg_verbose"
fi

echo -e "\n*** CALLING  $executable_name with inputs:   $_arg_input_file    $_arg_path_output   $_arg_output_file    $_arg_size_block    $multiple_files    $_arg_rows_output  $_arg_update_percentage"

#  Put escaped quotes (\") around input file and output folder names to accomodate possible paths which include white space.
cmd="$executable_path/$executable_name"
cmd=("${cmd[@]}" "\"$_arg_input_file\"" "\"$_arg_path_output\"" "\"$_arg_output_file\"" "$_arg_size_block $multiple_files $_arg_rows_output $_arg_update_percentage")
eval "${cmd[@]}"

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash